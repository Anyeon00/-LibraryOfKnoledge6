[단순하고 실용적인 컨트롤러 - v4]
v3까지 아키텍처는 완성됐지만, 개발자 입장에서 사용하기 번거롭다
개발자가 편리하게 개발할 수 있는 버전 만들기

개선된 점:
v3에서는 프론트 컨트롤러에서 request정보 Map만 생성해 컨트롤러에 넘겨주고,
컨트롤러는 Model(ModelView)를 생성해 return함
-> v4에서는 프론트 컨트롤러에서 request정보 Map과 Model로 사용할 빈 Map을 생성해 파라미터로 컨트롤러에 넘겨주고, 컨트롤러는 ViewName(jsp파일 논리적이름)만 return함
(뷰에 전달할 정보는 파라미터로 받은 Model인 Map에 그냥 넣으면 끝)

=> controller를 개발하는 개발자 입장에서는 파라미터로 받은 model에 정보를 저장하고, 뷰의 논리 이름을 return하면 끝
프론트컨트롤러 입장에서 model인 Map을 생성해 컨트롤러에 넘겨주고, 뷰의 논리 이름을 return받아서 뷰 리졸버로 parsing해서 jsp파일 path로 만들어, jsp파일 호출 및 http응답메시지 생성 등등 뒷 일을 처리해주게 됨


[유연한 컨트롤러1 - v5]
지금까지는 한 가지 방식으로만 컨트롤러를 다룰 수 있었음(서로 다른 컨트롤러 인터페이스를 이용하므로),
하지만 v1방식으로(controller 실행메서드에 파라미터로 request, response객체를 다 넘겨주는) 개발하고 싶은 사람도 있고, v2나 v3나 v4등 여러 방식으로 개발하고 싶은 경우
-> 어댑터 패턴
- 프론트 컨트롤러가 다양한 방식의 컨트롤러를 처리할 수 있게
- 이전에는 프론트 컨트롤러가 컨트롤러를 호출했지만, 이제는 이 어댑터를 통해서 호출함


* 핸들러 어댑터 : 중간에 어댑터가 추가되었는데, 이름이 핸들러 어댑터이다.
여기서 어댑터 역할을 해주는 덕분에 다양한 종류의 컨트롤러를 호출할 수 있다.
(각 컨트롤러의 프론트컨트롤러 역할)
* 핸들러 : 컨트롤러의 이름을 더 넓은 범위인 핸들러로 변경했다. 그 이유는 이제 어댑터가 있기 때문에 꼭 컨트롤러의 개념 뿐만 아니라 어떠한 것이든 해당하는 종류의 어댑터만 있으면 다 처리할 수 있기 때문이다.
(컨트롤러 역할)

과정:
1. FrontController에서 url요청받음
2. url정보로, 핸들러 매핑 정보에서 핸들러(컨트롤러)를 찾음
3. 핸들러 어댑터 리스트에서, 해당 핸들러를 처리할 수 있는 핸들러 어댑터를 찾음
(그 핸들러(컨트롤러)의 프론트컨트롤러 역할)
4. 해당 어댑터(프론트컨트롤러)를 통해 핸들러(컨트롤러)를 호출, ModelView반환
(만약 핸들러가 ModelView를 반환안하면, 어댑터에서 ModelView를 만들어서 FrontController에 반환 <- 이게 어댑터의 역할)
5. 뷰리졸버와 render메서드로 jsp파일호출과 http응답메시지 처리

* 내용 너무 어려워서 자세 내용은 강의 참고


[유연한 컨트롤러2 -v5]
위와 같이 변경한 덕분에, 새 어댑터를 하나 추가해서, 다른 버전의 핸들러들을 사용할 수 있게 됨


[정리]
더 편리하도록 v5에 어노테이션을 지원하는 어댑터를 추가할 수도 있음
-> 스프링 MVC _거의 비슷함
어댑터들이 다 구현 되어 있음
ex) @RequestMapping("/hello")
-> RequestMappingHandlerAdapter

* 사실 이파트 완벽하게 이해 못함 다시 보기

















